<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VRM Head Only AR (Bug Fix Final)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: white; font-family: sans-serif; }
        #container { position: relative; width: 100vw; height: 100vh; background-color: black; }
        
        /* èƒŒæ™¯æ˜ åƒ: åˆæœŸçŠ¶æ…‹ã¯éè¡¨ç¤º */
        #videoElement { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            object-fit: cover; 
            transform: scaleX(-1); 
            opacity: 0; 
            z-index: 0;
        }
        
        /* Three.js Canvas */
        canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 1;
            pointer-events: none;
        }
        
        #ui-layer {
            position: absolute; top: 10px; left: 10px; z-index: 10;
            background: rgba(0, 0, 0, 0.8); padding: 16px; border-radius: 12px;
            max-width: 340px;
            max-height: 95vh;
            overflow-y: auto;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            backdrop-filter: blur(5px);
            transition: opacity 0.3s;
        }
        
        #ui-layer.hidden-ui { opacity: 0; pointer-events: none; }

        #ui-toggle-btn {
            position: absolute; bottom: 20px; right: 20px; z-index: 20;
            width: 48px; height: 48px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            font-size: 24px; cursor: pointer;
            border: 1px solid rgba(255,255,255,0.3);
            pointer-events: auto;
        }

        #ui-layer::-webkit-scrollbar { width: 6px; }
        #ui-layer::-webkit-scrollbar-track { background: transparent; }
        #ui-layer::-webkit-scrollbar-thumb { background: #555; border-radius: 3px; }

        .btn {
            background: #3b82f6; color: white; padding: 10px 16px; border-radius: 6px;
            border: none; cursor: pointer; margin-bottom: 10px; width: 100%; font-weight: bold;
            transition: background 0.2s;
            pointer-events: auto;
        }
        .btn:hover { background: #2563eb; }
        .btn:disabled { background: #4b5563; cursor: not-allowed; opacity: 0.7; }
        
        .btn-secondary { background: #4b5563; }

        .status { font-size: 11px; margin-top: 8px; color: #9ca3af; line-height: 1.4; white-space: pre-wrap; }
        .debug-info { font-size: 10px; color: #4ade80; margin-top: 2px; font-family: monospace; font-weight: bold; }

        .control-group { margin-top: 16px; font-size: 13px; }
        .control-group label { display: flex; justify-content: space-between; margin-bottom: 6px; font-size: 12px; color: #d1d5db; font-weight: 500; }
        .control-group input[type=range] { width: 100%; cursor: pointer; accent-color: #3b82f6; pointer-events: auto; }
        
        .section-title {
            font-size: 11px; color: #6b7280; text-transform: uppercase; letter-spacing: 0.05em;
            margin-top: 20px; margin-bottom: 8px; border-bottom: 1px solid #374151; padding-bottom: 2px;
        }

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.85); padding: 24px; border-radius: 16px; display: none; z-index: 50;
            text-align: center;
        }
        
        #hide-hint {
            position: absolute; bottom: 10px; left: 10px; 
            color: rgba(255,255,255,0.5); font-size: 10px; pointer-events: none;
            z-index: 5;
        }

        #privacy-message {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #ef4444; font-weight: bold; font-size: 18px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            pointer-events: none; opacity: 0;
            z-index: 5; text-align: center;
        }
    </style>

    <!-- Import Maps -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
            "@pixiv/three-vrm": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@3.0.0/lib/three-vrm.module.js",
            "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.9/+esm"
        }
    }
    </script>
</head>
<body>

<div id="container">
    <video id="videoElement" playsinline></video>
    <div id="privacy-message">NO FACE DETECTED<br>VIDEO HIDDEN</div>
    
    <div id="ui-toggle-btn" title="UIè¡¨ç¤º/éè¡¨ç¤º">ğŸ‘ï¸</div>

    <div id="ui-layer">
        <h1 class="text-xl font-bold mb-4 text-white tracking-tight">Head Avatar AR</h1>
        
        <input type="file" id="vrmInput" accept=".vrm" style="display: none;">
        <button id="loadBtn" class="btn">1. VRMã‚’é¸æŠ</button>
        
        <div class="flex space-x-2">
            <button id="startBtn" class="btn" disabled>2. é–‹å§‹</button>
            <button id="switchCamBtn" class="btn btn-secondary" style="width: 80px;" disabled title="ã‚«ãƒ¡ãƒ©åˆ‡æ›¿">ğŸ“·</button>
        </div>
        
        <div class="mt-3 mb-2 p-3 bg-gray-800 rounded-lg border border-gray-700">
            <label class="flex items-center space-x-3 cursor-pointer">
                <div class="relative">
                    <input type="checkbox" id="showMaskDebug" class="sr-only peer">
                    <div class="w-9 h-5 bg-gray-600 peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-blue-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-red-600"></div>
                </div>
                <span class="text-sm font-medium text-red-300">ãƒ‡ãƒãƒƒã‚°è¡¨ç¤º (ãƒã‚¹ã‚¯ç¯„å›²)</span>
            </label>
            <div id="debugInfo" class="debug-info mt-1 ml-1">Mask: Waiting...</div>
        </div>

        <div class="section-title">ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­å®š</div>
        <div class="mt-2">
             <label class="flex items-center space-x-2 text-xs text-green-400 font-bold">
                <input type="checkbox" id="blackoutMode" checked> <span>é¡”æœªæ¤œå‡ºæ™‚ã¯ç”»é¢ã‚’é»’ãã™ã‚‹</span>
            </label>
        </div>

        <div class="section-title">ãƒã‚¹ã‚¯è¨­å®š</div>
        <div class="mt-2">
             <label class="flex items-center space-x-2 text-xs text-gray-300">
                <input type="checkbox" id="invertMask" checked> <span>ãƒã‚¹ã‚¯é ˜åŸŸã‚’åè»¢</span>
            </label>
        </div>
        
        <div class="section-title">å‹•ãã®åè»¢ (Mirror)</div>
        <div class="flex space-x-4 mb-2">
            <label class="flex items-center space-x-2 text-xs text-gray-300">
                <input type="checkbox" id="flipMoveX"> <span>ç§»å‹• (X)</span>
            </label>
            <label class="flex items-center space-x-2 text-xs text-gray-300">
                <input type="checkbox" id="flipRotY" checked> <span>å›è»¢ (Y)</span>
            </label>
        </div>

        <div class="section-title">ã‚¢ãƒã‚¿ãƒ¼èª¿æ•´</div>
        <div class="mt-2 mb-2">
             <label class="flex items-center space-x-2 text-xs text-gray-300">
                <input type="checkbox" id="flipAvatar180"> <span>ã‚¢ãƒã‚¿ãƒ¼ã‚’180åº¦å›è»¢</span>
            </label>
        </div>
        <div class="control-group">
            <label><span>ã‚µã‚¤ã‚º (Scale)</span> <span id="scaleVal" class="text-blue-400">2.00</span></label>
            <input type="range" id="scaleRange" min="0.5" max="10.0" step="0.01" value="2.0">
        </div>

        <div class="control-group">
            <label><span>ä¸Šä¸‹ä½ç½® (Y)</span> <span id="offsetYVal" class="text-blue-400">0.000</span></label>
            <input type="range" id="offsetYRange" min="-2.0" max="2.0" step="0.001" value="0.00">
        </div>

        <div class="control-group">
            <label><span>å·¦å³ä½ç½® (X)</span> <span id="offsetXVal" class="text-blue-400">0.000</span></label>
            <input type="range" id="offsetXRange" min="-2.0" max="2.0" step="0.001" value="0.00">
        </div>

        <div class="control-group">
            <label><span>å¥¥è¡Œã (Z)</span> <span id="offsetZVal" class="text-blue-400">-0.010</span></label>
            <input type="range" id="offsetZRange" min="-1.0" max="1.0" step="0.001" value="-0.01">
        </div>

        <div class="section-title">ãƒã‚¹ã‚¯ç©´èª¿æ•´</div>

        <div class="control-group">
            <label><span>é¡”ã®ç©´ã®å¹… (Width)</span> <span id="cutoutScaleVal" class="text-yellow-400">1.30</span></label>
            <input type="range" id="cutoutScaleRange" min="1.0" max="2.5" step="0.01" value="1.3">
        </div>
        <div class="control-group">
            <label><span>é¡”ã®ç©´ã®ä¸‹é™ (Chin)</span> <span id="cutoutBottomVal" class="text-yellow-400">1.10</span></label>
            <input type="range" id="cutoutBottomRange" min="0.8" max="2.0" step="0.01" value="1.1">
        </div>

        <div class="flex justify-end mt-4">
             <button id="resetPosBtn" class="text-xs bg-gray-700 hover:bg-gray-600 text-white py-1.5 px-4 rounded border border-gray-600 transition-colors">è¨­å®šãƒªã‚»ãƒƒãƒˆ</button>
        </div>
        
        <div id="statusText" class="status">åˆæœŸåŒ–ä¸­...</div>
    </div>
    
    <div id="hide-hint">ğŸ‘ï¸ãƒœã‚¿ãƒ³ ã¾ãŸã¯ [H]ã‚­ãƒ¼ ã§UIåˆ‡æ›¿</div>

    <div id="loading">
        <div class="flex flex-col items-center">
            <div class="animate-spin h-10 w-10 border-4 border-blue-500 rounded-full border-t-transparent mb-3"></div>
            <p id="loadingText" class="text-white font-bold text-sm">AIãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿ä¸­...</p>
        </div>
    </div>
</div>

<script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';
import { FilesetResolver, FaceLandmarker, ImageSegmenter } from '@mediapipe/tasks-vision'; 

const originalError = console.error;
console.error = function(...args) {
    if (args[0] && typeof args[0] === 'string' && args[0].includes('XNNPACK')) return;
    originalError.apply(console, args);
};

let scene, camera, renderer, clock;
let currentVrm = null;
let avatarHolder = null; 
let faceLandmarker = null;
let imageSegmenter = null; 
let videoElement = document.getElementById('videoElement');
let privacyMessage = document.getElementById('privacy-message');
let lastVideoTime = -1;
let isTracking = false;
let currentStream = null;
let currentFacingMode = 'user';

let segmentationMaskTexture = null; 
let videoTexture = null;
let occlusionPlane = null; 
let occlusionMaterial = null;
let maskCanvas = null;
let maskCtx = null;
let maskUpdateCount = 0; 

const FACE_OVAL_INDICES = [10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288, 397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136, 172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109];
const LEFT_EAR_INDEX = 234; 
const RIGHT_EAR_INDEX = 454; 

let params = {
    scale: 2.0, 
    offsetX: 0.0,
    offsetY: 0.0, 
    offsetZ: -0.01,
    cutoutScale: 1.3, 
    cutoutBottom: 1.1, 
    enableSegmentation: true, 
    invertMask: true, 
    showMaskDebug: false,
    flipMoveX: false,  
    flipRotY: true,
    flipAvatar180: false,
    blackoutMode: true 
};

const statusText = document.getElementById('statusText');
const debugInfo = document.getElementById('debugInfo');
const loadBtn = document.getElementById('loadBtn');
const startBtn = document.getElementById('startBtn');
const switchCamBtn = document.getElementById('switchCamBtn');
const vrmInput = document.getElementById('vrmInput');
const loadingEl = document.getElementById('loading');
const showMaskDebugCheck = document.getElementById('showMaskDebug');
const invertMaskCheck = document.getElementById('invertMask');
const resetPosBtn = document.getElementById('resetPosBtn');
const uiLayer = document.getElementById('ui-layer');
const uiToggleBtn = document.getElementById('ui-toggle-btn');
const flipMoveXCheck = document.getElementById('flipMoveX');
const flipRotYCheck = document.getElementById('flipRotY');
const flipAvatar180Check = document.getElementById('flipAvatar180'); 
const blackoutModeCheck = document.getElementById('blackoutMode');

const inputs = {
    scale: document.getElementById('scaleRange'),
    offsetX: document.getElementById('offsetXRange'),
    offsetY: document.getElementById('offsetYRange'),
    offsetZ: document.getElementById('offsetZRange'),
    cutoutScale: document.getElementById('cutoutScaleRange'),
    cutoutBottom: document.getElementById('cutoutBottomRange'),
};
const displays = {
    scale: document.getElementById('scaleVal'),
    offsetX: document.getElementById('offsetXVal'),
    offsetY: document.getElementById('offsetYVal'),
    offsetZ: document.getElementById('offsetZVal'),
    cutoutScale: document.getElementById('cutoutScaleVal'),
    cutoutBottom: document.getElementById('cutoutBottomVal'),
};

async function init() {
    const container = document.getElementById('container');
    
    scene = new THREE.Scene();
    clock = new THREE.Clock();

    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 0, 1); 
    camera.lookAt(0, 0, 0);

    renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true }); 
    renderer.setClearColor(0x000000, 0); 
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    avatarHolder = new THREE.Group();
    avatarHolder.renderOrder = 10; 
    scene.add(avatarHolder);

    const light = new THREE.DirectionalLight(0xffffff, 1.0);
    light.position.set(0, 0, 1); 
    scene.add(light);
    const ambient = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambient);

    window.addEventListener('resize', onWindowResize);
    
    const toggleUI = () => uiLayer.classList.toggle('hidden-ui');
    uiToggleBtn.addEventListener('click', toggleUI);
    window.addEventListener('keydown', (e) => {
        if (e.key === 'h' || e.key === 'H') toggleUI();
    });

    loadBtn.addEventListener('click', () => vrmInput.click());
    vrmInput.addEventListener('change', loadVRM);
    startBtn.addEventListener('click', startCameraAndTracking);
    switchCamBtn.addEventListener('click', switchCamera);
    
    showMaskDebugCheck.addEventListener('change', (e) => {
        params.showMaskDebug = e.target.checked;
        if(occlusionMaterial) occlusionMaterial.uniforms.uDebug.value = e.target.checked;
    });
    
    invertMaskCheck.addEventListener('change', (e) => { params.invertMask = e.target.checked; });
    flipMoveXCheck.addEventListener('change', (e) => { params.flipMoveX = e.target.checked; });
    flipRotYCheck.addEventListener('change', (e) => { params.flipRotY = e.target.checked; });
    flipAvatar180Check.addEventListener('change', (e) => { params.flipAvatar180 = e.target.checked; });
    blackoutModeCheck.addEventListener('change', (e) => { params.blackoutMode = e.target.checked; });
    
    resetPosBtn.addEventListener('click', resetParams);

    Object.keys(inputs).forEach(key => {
        inputs[key].addEventListener('input', (e) => {
            params[key] = parseFloat(e.target.value);
            const precision = (key.includes('offset')) ? 3 : 2;
            displays[key].innerText = params[key].toFixed(precision);
            
            if (key === 'scale' && avatarHolder) {
                const s = params.scale;
                avatarHolder.scale.set(s, s, s);
            }
        });
    });

    await initMediaPipe();
}

function resetParams() {
    params.scale = 2.0;
    params.offsetX = 0.0;
    params.offsetY = 0.0;
    params.offsetZ = -0.01;
    params.cutoutScale = 1.3;
    params.cutoutBottom = 1.1;
    params.showMaskDebug = false;
    params.invertMask = true;
    params.flipMoveX = false; 
    params.flipRotY = true;
    params.flipAvatar180 = false;
    params.blackoutMode = true;
    
    Object.keys(inputs).forEach(key => {
        inputs[key].value = params[key];
        const precision = (key.includes('offset')) ? 3 : 2;
        displays[key].innerText = params[key].toFixed(precision);
    });
    showMaskDebugCheck.checked = false;
    invertMaskCheck.checked = true;
    flipMoveXCheck.checked = false;
    flipRotYCheck.checked = true;
    flipAvatar180Check.checked = false;
    blackoutModeCheck.checked = true;

    if (avatarHolder) {
        const s = params.scale;
        avatarHolder.scale.set(s, s, s);
    }
    if(occlusionMaterial) occlusionMaterial.uniforms.uDebug.value = false;
    updateOcclusionPlaneTransform();
}

async function initMediaPipe() {
    statusText.innerText = "AIãƒ¢ãƒ‡ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ä¸­...";
    loadingEl.style.display = 'block';
    
    try {
        const vision = await FilesetResolver.forVisionTasks(
            "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.9/wasm"
        );
        
        faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
            baseOptions: {
                modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task`,
                delegate: "GPU" 
            },
            outputFaceBlendshapes: true,
            outputFacialTransformationMatrixes: true,
            runningMode: "VIDEO",
            numFaces: 1
        });

        try {
            imageSegmenter = await ImageSegmenter.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/image_segmenter/selfie_segmenter_landscape/float16/1/selfie_segmenter_landscape.tflite`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                outputCategoryMask: true,
                outputConfidenceMasks: false
            });
        } catch (segErr) {
            console.warn("Segmentation Init Error:", segErr);
            params.enableSegmentation = false;
        }
        
        statusText.innerText = "æº–å‚™å®Œäº†: VRMã‚’é¸æŠã—ã¦ãã ã•ã„";
        loadingEl.style.display = 'none';
        
    } catch (error) {
        console.error("Init Error:", error);
        statusText.innerText = "åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: " + error.message;
        document.getElementById('loadingText').innerText = "ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ";
        setTimeout(() => loadingEl.style.display = 'none', 3000);
    }
}

function loadVRM(event) {
    const file = event.target.files[0];
    if (!file) return;

    const url = URL.createObjectURL(file);
    const loader = new GLTFLoader();
    loader.register((parser) => new VRMLoaderPlugin(parser));

    statusText.innerText = "VRMèª­ã¿è¾¼ã¿ä¸­...";
    loadingEl.style.display = 'block';
    document.getElementById('loadingText').innerText = "VRMèª­ã¿è¾¼ã¿ä¸­...";

    loader.load(
        url,
        (gltf) => {
            if (currentVrm) {
                avatarHolder.remove(currentVrm.scene);
                VRMUtils.deepDispose(currentVrm.scene);
            }
            avatarHolder.position.set(0,0,0);
            avatarHolder.rotation.set(0,0,0);
            avatarHolder.scale.set(1,1,1);

            const vrm = gltf.userData.vrm;
            currentVrm = vrm;
            
            vrm.scene.traverse((obj) => {
                if (obj.isSkinnedMesh || obj.isMesh) {
                    const name = obj.name.toLowerCase();
                    const isHeadPart = name.includes('face') || name.includes('head') || name.includes('hair') || name.includes('eye') || name.includes('tooth') || name.includes('mouth') || name.includes('ear') || name.includes('brow');
                    obj.visible = isHeadPart;
                }
            });

            scene.add(vrm.scene);
            vrm.scene.updateMatrixWorld(true);
            const headBone = vrm.humanoid.getNormalizedBoneNode('head');
            let headOffset = 1.4; 
            if (headBone) {
                const headPos = new THREE.Vector3();
                headBone.getWorldPosition(headPos);
                headOffset = headPos.y; 
            }
            scene.remove(vrm.scene);
            avatarHolder.add(vrm.scene);
            vrm.scene.position.set(0, -headOffset, 0);
            
            const s = params.scale;
            avatarHolder.scale.set(s, s, s);

            VRMUtils.removeUnnecessaryVertices(vrm.scene);
            VRMUtils.removeUnnecessaryJoints(vrm.scene);

            console.log("VRM Loaded");
            statusText.innerText = "VRMèª­è¾¼å®Œäº†ã€‚ã€Œ2. é–‹å§‹ã€ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚";
            startBtn.disabled = false;
            switchCamBtn.disabled = false;
            loadingEl.style.display = 'none';
        },
        (progress) => {},
        (error) => {
            console.error(error);
            statusText.innerText = "VRMã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ";
            loadingEl.style.display = 'none';
        }
    );
}

async function switchCamera() {
    currentFacingMode = (currentFacingMode === 'user') ? 'environment' : 'user';
    if (currentStream) currentStream.getTracks().forEach(track => track.stop());
    isTracking = false;
    await startCameraAndTracking();
}

async function startCameraAndTracking() {
    if (!faceLandmarker) {
        alert("AIãƒ¢ãƒ‡ãƒ«ãŒã¾ã æº–å‚™ã§ãã¦ã„ã¾ã›ã‚“ã€‚");
        return;
    }
    
    startBtn.disabled = true;
    switchCamBtn.disabled = true;

    try {
        statusText.innerText = "ã‚«ãƒ¡ãƒ©èµ·å‹•ä¸­...";
        if (currentStream) currentStream.getTracks().forEach(track => track.stop());

        const stream = await navigator.mediaDevices.getUserMedia({ 
            video: { width: { ideal: 1280 }, height: { ideal: 720 }, facingMode: currentFacingMode } 
        });
        currentStream = stream;
        videoElement.srcObject = stream;
        
        if (currentFacingMode === 'user') {
            videoElement.style.transform = 'scaleX(-1)';
        } else {
            videoElement.style.transform = 'scaleX(1)';
        }

        await videoElement.play();
        
        await new Promise((resolve) => {
            if (videoElement.readyState >= 2) {
                resolve();
            } else {
                videoElement.onloadeddata = () => resolve();
                setTimeout(resolve, 3000);
            }
        });
        onWindowResize();

        videoTexture = new THREE.VideoTexture(videoElement);
        videoTexture.colorSpace = THREE.SRGBColorSpace;
        scene.background = null; 

        if (params.enableSegmentation && imageSegmenter) {
            maskCanvas = document.createElement('canvas');
            maskCanvas.width = videoElement.videoWidth;
            maskCanvas.height = videoElement.videoHeight;
            maskCtx = maskCanvas.getContext('2d');

            segmentationMaskTexture = new THREE.CanvasTexture(maskCanvas);
            segmentationMaskTexture.minFilter = THREE.LinearFilter;
            
            occlusionMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    uVideo: { value: videoTexture },
                    uMask: { value: segmentationMaskTexture },
                    uDebug: { value: params.showMaskDebug }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D uVideo;
                    uniform sampler2D uMask;
                    uniform bool uDebug;
                    varying vec2 vUv;
                    void main() {
                        vec4 videoColor = texture2D(uVideo, vUv);
                        float maskAlpha = texture2D(uMask, vUv).a;
                        if (uDebug) {
                            gl_FragColor = vec4(1.0, 0.0, 0.0, maskAlpha * 0.6);
                        } else {
                            if (maskAlpha > 0.5) {
                                gl_FragColor = vec4(videoColor.rgb, 1.0);
                            } else {
                                discard;
                            }
                        }
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide,
                depthWrite: true 
            });
            
            const planeGeometry = new THREE.PlaneGeometry(1, 1); 
            occlusionPlane = new THREE.Mesh(planeGeometry, occlusionMaterial);
            
            occlusionPlane.renderOrder = 999; 
            occlusionPlane.position.set(0, 0, 0.5); 
            occlusionPlane.visible = false; 
            
            scene.add(occlusionPlane);
            updateOcclusionPlaneTransform();
        }

        isTracking = true;
        startBtn.innerText = "å‹•ä½œä¸­";
        statusText.innerText = "ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°ä¸­...";
        
        animate();
        
    } catch (e) {
        console.error("Camera Error:", e);
        statusText.innerText = "ã‚«ãƒ¡ãƒ©èµ·å‹•å¤±æ•—: " + e.message;
        startBtn.disabled = false;
        switchCamBtn.disabled = false;
    }
}

function updateOcclusionPlaneTransform() {
    if (!occlusionPlane || !videoElement || videoElement.videoWidth === 0) return;

    occlusionPlane.visible = params.enableSegmentation;
    if (!params.enableSegmentation) return;

    const videoAspect = videoElement.videoWidth / videoElement.videoHeight;
    const screenAspect = window.innerWidth / window.innerHeight;
    
    const distance = 0.5; 
    const vFOV = camera.fov * Math.PI / 180;
    
    const visibleHeight = 2 * Math.tan(vFOV / 2) * distance;
    const visibleWidth = visibleHeight * screenAspect;

    let scaleX, scaleY;

    if (screenAspect > videoAspect) {
        scaleX = visibleWidth;
        scaleY = visibleWidth / videoAspect; 
    } else {
        scaleY = visibleHeight;
        scaleX = visibleHeight * videoAspect; 
    }
    
    const isFront = (currentFacingMode === 'user');
    const dir = isFront ? -1 : 1;
    
    occlusionPlane.scale.set(scaleX * dir, scaleY, 1);
}

function animate() {
    requestAnimationFrame(animate);
    const deltaTime = clock.getDelta();
    let startTimeMs = performance.now();

    if (isTracking && videoElement.readyState >= 2 && videoElement.videoWidth > 0) { 
        if (videoElement.currentTime !== lastVideoTime) {
            lastVideoTime = videoElement.currentTime;
            
            try {
                const faceResult = faceLandmarker.detectForVideo(videoElement, startTimeMs);
                let faceLandmarks = null;
                
                if (faceResult.faceLandmarks && faceResult.faceLandmarks.length > 0) {
                    faceLandmarks = faceResult.faceLandmarks[0]; 
                    updateAvatarPose(faceResult);
                    
                    if (currentVrm) currentVrm.scene.visible = true;
                    if (occlusionPlane) occlusionPlane.visible = true; 
                    videoElement.style.opacity = 1;
                    privacyMessage.style.opacity = 0;
                    statusText.innerText = "ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°ä¸­";
                } else {
                    statusText.innerText = "é¡”ã‚’æ¢ã—ã¦ã„ã¾ã™...";
                    if (params.blackoutMode) {
                        if (currentVrm) currentVrm.scene.visible = false;
                        if (occlusionPlane) occlusionPlane.visible = false;
                        videoElement.style.opacity = 0;
                        privacyMessage.style.opacity = 1;
                    }
                }

                if (imageSegmenter && occlusionPlane && occlusionMaterial && params.enableSegmentation) {
                    const segResult = imageSegmenter.segmentForVideo(videoElement, startTimeMs);
                    if (segResult) {
                        try {
                            if (segResult.categoryMask) {
                                updateOcclusionMask(segResult.categoryMask, faceLandmarks);
                                maskUpdateCount++;
                            }
                        } finally {
                            if (segResult.categoryMask) segResult.categoryMask.close();
                            if (segResult.confidenceMasks) {
                                for (const m of segResult.confidenceMasks) m.close();
                            }
                        }
                    }
                    occlusionMaterial.needsUpdate = true;
                    if(segmentationMaskTexture) segmentationMaskTexture.needsUpdate = true;
                    
                    if (params.showMaskDebug) {
                        occlusionMaterial.uniforms.uDebug.value = true;
                    } else {
                        occlusionMaterial.uniforms.uDebug.value = false;
                    }
                } else {
                    if (occlusionPlane) occlusionPlane.visible = false;
                }
            } catch (e) {
               console.warn(e);
            }
        }
    }
    
    if (currentVrm) {
        currentVrm.update(deltaTime);
    }
    
    renderer.render(scene, camera);
}

function updateOcclusionMask(mask, faceLandmarks) {
    if (maskCanvas.width !== videoElement.videoWidth) {
        maskCanvas.width = videoElement.videoWidth;
        maskCanvas.height = videoElement.videoHeight;
    }

    const width = maskCanvas.width;
    const height = maskCanvas.height;
    const maskArray = mask.getAsUint8Array(); 
    const imgData = maskCtx.createImageData(width, height);
    const invert = params.invertMask;
    
    for (let i = 0; i < width * height; ++i) {
        const category = maskArray[i];
        const pixelIndex = i * 4;
        let alpha;

        const isPerson = category > 0;
        let shouldMask = isPerson;
        if (invert) shouldMask = !shouldMask; 

        alpha = shouldMask ? 255 : 0;
        
        imgData.data[pixelIndex] = 255;     
        imgData.data[pixelIndex + 1] = 255;   
        imgData.data[pixelIndex + 2] = 255;   
        imgData.data[pixelIndex + 3] = alpha; 
    }

    maskCtx.putImageData(imgData, 0, 0);
    
    if (faceLandmarks) {
        maskCtx.globalCompositeOperation = 'destination-out'; 
        maskCtx.fillStyle = 'rgba(0,0,0,1)'; 
        
        let minX = 1.0, minY = 1.0, maxX = 0.0, maxY = 0.0;
        for (let i = 0; i < FACE_OVAL_INDICES.length; i++) {
            const idx = FACE_OVAL_INDICES[i];
            const p = faceLandmarks[idx];
            if (p.x < minX) minX = p.x;
            if (p.x > maxX) maxX = p.x;
            if (p.y < minY) minY = p.y;
            if (p.y > maxY) maxY = p.y;
        }

        const boxX = minX * width;
        const boxY = minY * height;
        const boxW = (maxX - minX) * width;
        const boxH = (maxY - minY) * height;
        const centerX = boxX + boxW / 2;
        const centerY = boxY + boxH / 2;

        const leftEar = faceLandmarks[LEFT_EAR_INDEX];
        const rightEar = faceLandmarks[RIGHT_EAR_INDEX];
        const dx = (rightEar.x - leftEar.x); 
        const dy = (rightEar.y - leftEar.y);
        const rotation = Math.atan2(dy, dx); 

        const scaleW = params.cutoutScale; 
        const scaleH = params.cutoutBottom; 
        const radiusX = (boxW / 2) * scaleW; 
        const radiusY = (boxH / 2) * scaleH; 

        maskCtx.save();
        maskCtx.translate(centerX, centerY);
        maskCtx.rotate(rotation); 
        
        maskCtx.beginPath();
        maskCtx.scale(radiusX, radiusY);
        maskCtx.arc(0, 0, 1, 0, Math.PI); 
        maskCtx.fill();
        
        maskCtx.beginPath();
        maskCtx.rect(-1.5, -10, 3, 10); 
        maskCtx.fill();

        maskCtx.restore();
        maskCtx.globalCompositeOperation = 'source-over';
    }

    if (segmentationMaskTexture) {
        segmentationMaskTexture.needsUpdate = true;
    }
    
    if (maskUpdateCount % 60 === 0) {
        debugInfo.innerText = `Mask OK`;
    }
}

function updateAvatarPose(result) {
    if (!currentVrm || !avatarHolder) return;
    const matrix = result.facialTransformationMatrixes[0].data;
    const blendshapes = result.faceBlendshapes[0].categories;
    const mpMatrix = new THREE.Matrix4().fromArray(matrix);
    const position = new THREE.Vector3();
    const quaternion = new THREE.Quaternion();
    const scale = new THREE.Vector3();
    mpMatrix.decompose(position, quaternion, scale);
    const AR_SCALE_FACTOR = 0.08; 
    
    const xDir = params.flipMoveX ? 1 : -1;
    const yRotDir = params.flipRotY ? -1 : 1;
    const avatarRot = params.flipAvatar180 ? Math.PI : 0;

    avatarHolder.position.x = (position.x * AR_SCALE_FACTOR * xDir) + params.offsetX; 
    avatarHolder.position.y = (position.y * AR_SCALE_FACTOR) + params.offsetY;
    avatarHolder.position.z = (position.z * AR_SCALE_FACTOR) + params.offsetZ;
    
    const euler = new THREE.Euler().setFromQuaternion(quaternion, 'YXZ');
    avatarHolder.rotation.y = (euler.y * yRotDir) + Math.PI + avatarRot; 
    avatarHolder.rotation.x = euler.x;
    avatarHolder.rotation.z = euler.z;
    
    if (currentVrm.expressionManager) {
        const map = { 'jawOpen': 'aa', 'mouthPucker': 'ou', 'mouthSmileLeft': 'happy', 'mouthSmileRight': 'happy', 'eyeBlinkLeft': 'blinkLeft', 'eyeBlinkRight': 'blinkRight', 'browInnerUp': 'surprised' };
        currentVrm.expressionManager.expressions.forEach((expr, name) => { if (map[name] === undefined) currentVrm.expressionManager.setValue(name, 0); });
        blendshapes.forEach(shape => { const vrmName = map[shape.categoryName]; if (vrmName) currentVrm.expressionManager.setValue(vrmName, shape.score); });
        const smileL = blendshapes.find(b => b.categoryName === 'mouthSmileLeft')?.score || 0;
        const smileR = blendshapes.find(b => b.categoryName === 'mouthSmileRight')?.score || 0;
        currentVrm.expressionManager.setValue('happy', Math.max(smileL, smileR)); 
    }
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    updateOcclusionPlaneTransform();
}

init();
</script>
</body>
</html>
