<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VRM Head Only AR (Narrow Mask)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: white; font-family: sans-serif; }
        #container { position: relative; width: 100vw; height: 100vh; background-color: black; }
        
        /* Layer 0: èƒŒæ™¯æ˜ åƒ (WebCam) */
        #videoElement { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            object-fit: cover; 
            transform: scaleX(-1); 
            opacity: 0; 
            z-index: 0;
        }

        /* Layer 0.5: å¾…æ©Ÿç”»åƒ (é¡”ãƒ­ã‚¹ãƒˆæ™‚ã«è¡¨ç¤º) */
        #standbyImageLayer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover;
            opacity: 0;
            z-index: 1;
            pointer-events: none;
            background-color: black;
            display: flex; align-items: center; justify-content: center;
            transition: opacity 0.5s;
        }
        #standbyImage {
            width: 100%; height: 100%; object-fit: cover; display: none;
        }
        
        /* Layer 1-3: Three.js Canvas */
        canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 2;
            pointer-events: none;
        }
        
        #ui-layer {
            position: absolute; top: 10px; left: 10px; z-index: 10;
            background: rgba(0, 0, 0, 0.8); padding: 16px; border-radius: 12px;
            max-width: 340px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            backdrop-filter: blur(5px);
            transition: opacity 0.3s;
        }
        
        #ui-layer.hidden-ui { opacity: 0; pointer-events: none; }

        #ui-toggle-btn {
            position: absolute; bottom: 20px; right: 20px; z-index: 20;
            width: 48px; height: 48px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            font-size: 24px; cursor: pointer;
            border: 1px solid rgba(255,255,255,0.3);
            pointer-events: auto;
        }

        /* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼è£…é£¾ */
        #ui-layer::-webkit-scrollbar { width: 6px; }
        #ui-layer::-webkit-scrollbar-track { background: transparent; }
        #ui-layer::-webkit-scrollbar-thumb { background: #555; border-radius: 3px; }

        .btn {
            background: #3b82f6; color: white; padding: 10px 16px; border-radius: 6px;
            border: none; cursor: pointer; margin-bottom: 10px; width: 100%; font-weight: bold;
            transition: background 0.2s;
            pointer-events: auto;
        }
        .btn:hover { background: #2563eb; }
        .btn:disabled { background: #4b5563; cursor: not-allowed; opacity: 0.7; }
        
        .btn-secondary { background: #4b5563; }

        .status { font-size: 11px; margin-top: 8px; color: #9ca3af; line-height: 1.4; white-space: pre-wrap; }
        .debug-info { font-size: 10px; color: #4ade80; margin-top: 2px; font-family: monospace; font-weight: bold; }

        .control-group { margin-top: 16px; font-size: 13px; }
        .control-group label { display: flex; justify-content: space-between; margin-bottom: 6px; font-size: 12px; color: #d1d5db; font-weight: 500; }
        .control-group input[type=range] { width: 100%; cursor: pointer; accent-color: #3b82f6; pointer-events: auto; }
        
        .section-title {
            font-size: 11px; color: #6b7280; text-transform: uppercase; letter-spacing: 0.05em;
            margin-top: 20px; margin-bottom: 8px; border-bottom: 1px solid #374151; padding-bottom: 2px;
        }

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.85); padding: 24px; border-radius: 16px; display: none; z-index: 50;
            text-align: center;
        }
        
        #hide-hint {
            position: absolute; bottom: 10px; left: 10px; 
            color: rgba(255,255,255,0.5); font-size: 10px; pointer-events: none;
            z-index: 5;
        }

        #privacy-message {
            color: #ef4444; font-weight: bold; font-size: 18px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            text-align: center;
            display: none;
        }
    </style>

    <!-- Import Maps -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
            "@pixiv/three-vrm": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@3.0.0/lib/three-vrm.module.js",
            "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.9/+esm"
        }
    }
    </script>
</head>
<body>

<div id="container">
    <!-- Layer 0 -->
    <video id="videoElement" playsinline></video>
    
    <!-- Layer 0.5: Standby Image / Blackout -->
    <div id="standbyImageLayer">
        <img id="standbyImage" alt="Standby">
        <div id="privacy-message">NO FACE DETECTED<br>VIDEO HIDDEN</div>
    </div>
    
    <div id="ui-toggle-btn" title="UIè¡¨ç¤º/éè¡¨ç¤º">ğŸ‘ï¸</div>

    <div id="ui-layer">
        <h1 class="text-xl font-bold mb-4 text-white tracking-tight">Head Avatar AR <span class="text-xs text-blue-400 font-normal">v2.2</span></h1>
        
        <input type="file" id="vrmInput" accept=".vrm" style="display: none;">
        <button id="loadBtn" class="btn">1. VRMã‚’é¸æŠ</button>
        
        <div class="flex space-x-2">
            <button id="startBtn" class="btn" disabled>2. é–‹å§‹</button>
            <button id="switchCamBtn" class="btn btn-secondary" style="width: 80px;" disabled title="ã‚«ãƒ¡ãƒ©åˆ‡æ›¿">ğŸ“·</button>
        </div>
        
        <div class="mt-3 mb-2 p-3 bg-gray-800 rounded-lg border border-gray-700">
            <label class="flex items-center space-x-3 cursor-pointer">
                <div class="relative">
                    <input type="checkbox" id="showMaskDebug" class="sr-only peer">
                    <div class="w-9 h-5 bg-gray-600 peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-blue-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-red-600"></div>
                </div>
                <span class="text-sm font-medium text-red-300">ãƒ‡ãƒãƒƒã‚°è¡¨ç¤º (ãƒã‚¹ã‚¯ç¯„å›²)</span>
            </label>
            <div id="debugInfo" class="debug-info mt-1 ml-1">Mask: Waiting...</div>
        </div>

        <div class="section-title">å¾…æ©Ÿç”»é¢ãƒ»ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£</div>
        <div class="mt-2">
             <label class="flex items-center space-x-2 text-xs text-green-400 font-bold mb-2">
                <input type="checkbox" id="blackoutMode" checked> <span>é¡”æœªæ¤œå‡ºæ™‚ã¯ç”»é¢ã‚’éš ã™</span>
            </label>
            
            <input type="file" id="imageInput" accept="image/*" style="display: none;">
            <button id="uploadImgBtn" class="btn btn-secondary text-xs py-2">å¾…æ©Ÿç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ (ä»»æ„)</button>
            <div id="imgStatus" class="text-[10px] text-gray-400 text-right">ç”»åƒãªã— (é»’ç”»é¢)</div>
        </div>

        <div class="section-title">ãƒã‚¹ã‚¯è¨­å®š</div>
        <div class="mt-2">
             <label class="flex items-center space-x-2 text-xs text-gray-300">
                <input type="checkbox" id="invertMask" checked> <span>ãƒã‚¹ã‚¯é ˜åŸŸã‚’åè»¢</span>
            </label>
        </div>
        
        <div class="section-title">å‹•ãã®è¨­å®š</div>
        <div class="flex space-x-4 mb-2">
            <label class="flex items-center space-x-2 text-xs text-gray-300">
                <input type="checkbox" id="flipMoveX"> <span>ç§»å‹• (X)</span>
            </label>
            <label class="flex items-center space-x-2 text-xs text-gray-300">
                <input type="checkbox" id="flipRotY" checked> <span>å›è»¢ (Y)</span>
            </label>
        </div>
        <div class="control-group">
            <label><span>æ»‘ã‚‰ã‹ã• (Smoothing)</span> <span id="smoothVal" class="text-green-400">0.50</span></label>
            <input type="range" id="smoothRange" min="0.1" max="0.95" step="0.05" value="0.5">
        </div>

        <div class="section-title">ã‚¢ãƒã‚¿ãƒ¼èª¿æ•´</div>
        <div class="mt-2 mb-2">
             <label class="flex items-center space-x-2 text-xs text-gray-300">
                <input type="checkbox" id="flipAvatar180"> <span>ã‚¢ãƒã‚¿ãƒ¼ã‚’180åº¦å›è»¢</span>
            </label>
        </div>
        <div class="control-group">
            <label><span>ã‚µã‚¤ã‚º (Scale)</span> <span id="scaleVal" class="text-blue-400">2.00</span></label>
            <input type="range" id="scaleRange" min="0.5" max="10.0" step="0.01" value="2.0">
        </div>

        <div class="control-group">
            <label><span>ä¸Šä¸‹ä½ç½® (Y)</span> <span id="offsetYVal" class="text-blue-400">0.000</span></label>
            <input type="range" id="offsetYRange" min="-2.0" max="2.0" step="0.001" value="0.00">
        </div>

        <div class="control-group">
            <label><span>å·¦å³ä½ç½® (X)</span> <span id="offsetXVal" class="text-blue-400">0.000</span></label>
            <input type="range" id="offsetXRange" min="-2.0" max="2.0" step="0.001" value="0.00">
        </div>

        <div class="control-group">
            <label><span>å¥¥è¡Œã (Z)</span> <span id="offsetZVal" class="text-blue-400">-0.010</span></label>
            <input type="range" id="offsetZRange" min="-1.0" max="1.0" step="0.001" value="-0.01">
        </div>

        <div class="section-title">ãƒã‚¹ã‚¯ç©´ (ãã‚ŠæŠœã) èª¿æ•´</div>
        <div class="text-[10px] text-gray-400 mb-2">
            ã‚¢ãƒã‚¿ãƒ¼ãŒè¦‹ãˆã‚‹ç¯„å›²ã‚’èª¿æ•´ã—ã¾ã™
        </div>

        <!-- é¡”ã®åºƒã•ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’1.5ã‹ã‚‰1.3ã«å¤‰æ›´ -->
        <div class="control-group">
            <label><span>é¡”ã®åºƒã• (Face Width)</span> <span id="cutoutScaleVal" class="text-yellow-400">1.30</span></label>
            <input type="range" id="cutoutScaleRange" min="1.0" max="3.0" step="0.05" value="1.3">
        </div>
        <div class="control-group">
            <label><span>ã‚¢ã‚´ä¸‹ã®åºƒã• (Chin)</span> <span id="cutoutBottomVal" class="text-yellow-400">1.00</span></label>
            <input type="range" id="cutoutBottomRange" min="0.5" max="2.0" step="0.05" value="1.0">
        </div>
        <div class="control-group">
            <label><span>ãŠã§ã“ä¸Šã®åºƒã• (Forehead)</span> <span id="cutoutTopVal" class="text-yellow-400">2.00</span></label>
            <input type="range" id="cutoutTopRange" min="1.0" max="5.0" step="0.1" value="2.0">
            <div class="text-[10px] text-gray-500 text-right">å€¤ã‚’ä¸Šã’ã‚‹ã¨é«ªãŒåˆ‡ã‚Œã«ãããªã‚Šã¾ã™</div>
        </div>

        <div class="flex justify-end mt-4">
             <button id="resetPosBtn" class="text-xs bg-gray-700 hover:bg-gray-600 text-white py-1.5 px-4 rounded border border-gray-600 transition-colors">è¨­å®šãƒªã‚»ãƒƒãƒˆ</button>
        </div>
        
        <div id="statusText" class="status">åˆæœŸåŒ–ä¸­...</div>
    </div>
    
    <div id="hide-hint">ğŸ‘ï¸ãƒœã‚¿ãƒ³ ã¾ãŸã¯ [H]ã‚­ãƒ¼ ã§UIåˆ‡æ›¿</div>

    <div id="loading">
        <div class="flex flex-col items-center">
            <div class="animate-spin h-10 w-10 border-4 border-blue-500 rounded-full border-t-transparent mb-3"></div>
            <p id="loadingText" class="text-white font-bold text-sm">AIãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿ä¸­...</p>
        </div>
    </div>
</div>

<script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';
import { FilesetResolver, FaceLandmarker, ImageSegmenter } from '@mediapipe/tasks-vision'; 

const originalError = console.error;
console.error = function(...args) {
    if (args[0] && typeof args[0] === 'string' && args[0].includes('XNNPACK')) return;
    originalError.apply(console, args);
};

// --- ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•° ---
let scene, camera, renderer, clock;
let currentVrm = null;
let avatarHolder = null; 
let faceLandmarker = null;
let imageSegmenter = null; 
let videoElement = document.getElementById('videoElement');
let privacyMessage = document.getElementById('privacy-message');
let standbyLayer = document.getElementById('standbyImageLayer');
let standbyImg = document.getElementById('standbyImage');
let lastVideoTime = -1;
let isTracking = false;
let currentStream = null;
let currentFacingMode = 'user';

let segmentationMaskTexture = null; 
let videoTexture = null;
let occlusionPlane = null; 
let occlusionMaterial = null;
let maskCanvas = null;
let maskCtx = null;
let maskUpdateCount = 0; 
let hasCustomImage = false;

// ä¿®æ­£: é¡”ã®è¼ªéƒ­ç‚¹ã‹ã‚‰ã€æ¨ªå´ã®ç‚¹(è€³ã«è¿‘ã„éƒ¨åˆ†)ã‚’å‰Šé™¤ã—ã¦ç‹­ãã—ãŸ
// å‰Šé™¤ã—ãŸç‚¹: å³å´[454, 323, 361], å·¦å´[132, 93, 234]
const FACE_OVAL_INDICES = [10, 338, 297, 332, 284, 251, 389, 356, 288, 397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136, 172, 58, 127, 162, 21, 54, 103, 67, 109];

// --- ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¨UIè¦ç´  ---
let params = {
    scale: 2.0, 
    offsetX: 0.0,
    offsetY: 0.0, 
    offsetZ: -0.01,
    
    // ãƒã‚¹ã‚¯èª¿æ•´ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    cutoutScale: 1.3,  // é¡”ã®åºƒã•ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’1.3ã«å¤‰æ›´
    cutoutBottom: 1.0, 
    cutoutTop: 2.0,    
    
    enableSegmentation: true, 
    invertMask: true, 
    showMaskDebug: false,
    
    flipMoveX: false,  
    flipRotY: true,
    flipAvatar180: false,
    blackoutMode: true,
    
    smoothFactor: 0.5
};

// --- ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°ç”¨ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆå¤‰æ•° ---
let targetPosition = new THREE.Vector3(0,0,0);
let targetQuaternion = new THREE.Quaternion();
let targetExpressions = {}; 

const statusText = document.getElementById('statusText');
const debugInfo = document.getElementById('debugInfo');
const loadBtn = document.getElementById('loadBtn');
const startBtn = document.getElementById('startBtn');
const switchCamBtn = document.getElementById('switchCamBtn');
const vrmInput = document.getElementById('vrmInput');
const imgInput = document.getElementById('imageInput');
const uploadImgBtn = document.getElementById('uploadImgBtn');
const imgStatus = document.getElementById('imgStatus');
const loadingEl = document.getElementById('loading');
const showMaskDebugCheck = document.getElementById('showMaskDebug');
const invertMaskCheck = document.getElementById('invertMask');
const resetPosBtn = document.getElementById('resetPosBtn');
const uiLayer = document.getElementById('ui-layer');
const uiToggleBtn = document.getElementById('ui-toggle-btn');
const flipMoveXCheck = document.getElementById('flipMoveX');
const flipRotYCheck = document.getElementById('flipRotY');
const flipAvatar180Check = document.getElementById('flipAvatar180'); 
const blackoutModeCheck = document.getElementById('blackoutMode');

const inputs = {
    scale: document.getElementById('scaleRange'),
    offsetX: document.getElementById('offsetXRange'),
    offsetY: document.getElementById('offsetYRange'),
    offsetZ: document.getElementById('offsetZRange'),
    cutoutScale: document.getElementById('cutoutScaleRange'),
    cutoutBottom: document.getElementById('cutoutBottomRange'),
    cutoutTop: document.getElementById('cutoutTopRange'),
    smoothFactor: document.getElementById('smoothRange'),
};
const displays = {
    scale: document.getElementById('scaleVal'),
    offsetX: document.getElementById('offsetXVal'),
    offsetY: document.getElementById('offsetYVal'),
    offsetZ: document.getElementById('offsetZVal'),
    cutoutScale: document.getElementById('cutoutScaleVal'),
    cutoutBottom: document.getElementById('cutoutBottomVal'),
    cutoutTop: document.getElementById('cutoutTopVal'),
    smoothFactor: document.getElementById('smoothVal'),
};

async function init() {
    const container = document.getElementById('container');
    
    scene = new THREE.Scene();
    clock = new THREE.Clock();

    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 0, 1); 
    camera.lookAt(0, 0, 0);

    renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true }); 
    renderer.setClearColor(0x000000, 0); 
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    avatarHolder = new THREE.Group();
    avatarHolder.renderOrder = 10; 
    scene.add(avatarHolder);

    const light = new THREE.DirectionalLight(0xffffff, 1.0);
    light.position.set(0, 0, 1); 
    scene.add(light);
    const ambient = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambient);

    window.addEventListener('resize', onWindowResize);
    
    const toggleUI = () => uiLayer.classList.toggle('hidden-ui');
    uiToggleBtn.addEventListener('click', toggleUI);
    window.addEventListener('keydown', (e) => {
        if (e.key === 'h' || e.key === 'H') toggleUI();
    });

    loadBtn.addEventListener('click', () => vrmInput.click());
    vrmInput.addEventListener('change', loadVRM);
    
    uploadImgBtn.addEventListener('click', () => imgInput.click());
    imgInput.addEventListener('change', loadImage);
    
    startBtn.addEventListener('click', startCameraAndTracking);
    switchCamBtn.addEventListener('click', switchCamera);
    
    showMaskDebugCheck.addEventListener('change', (e) => {
        params.showMaskDebug = e.target.checked;
        if(occlusionMaterial) occlusionMaterial.uniforms.uDebug.value = e.target.checked;
    });
    
    invertMaskCheck.addEventListener('change', (e) => { params.invertMask = e.target.checked; });
    flipMoveXCheck.addEventListener('change', (e) => { params.flipMoveX = e.target.checked; });
    flipRotYCheck.addEventListener('change', (e) => { params.flipRotY = e.target.checked; });
    flipAvatar180Check.addEventListener('change', (e) => { params.flipAvatar180 = e.target.checked; });
    blackoutModeCheck.addEventListener('change', (e) => { params.blackoutMode = e.target.checked; });
    
    resetPosBtn.addEventListener('click', resetParams);

    Object.keys(inputs).forEach(key => {
        inputs[key].addEventListener('input', (e) => {
            params[key] = parseFloat(e.target.value);
            const precision = (key.includes('offset')) ? 3 : 2;
            if(displays[key]) displays[key].innerText = params[key].toFixed(precision);
            
            if (key === 'scale' && avatarHolder) {
                const s = params.scale;
                avatarHolder.scale.set(s, s, s);
            }
        });
    });

    await initMediaPipe();
}

function resetParams() {
    params.scale = 2.0;
    params.offsetX = 0.0;
    params.offsetY = 0.0;
    params.offsetZ = -0.01;
    
    params.cutoutScale = 1.3; // ãƒªã‚»ãƒƒãƒˆæ™‚ã‚‚1.3ã«æˆ»ã™
    params.cutoutBottom = 1.0;
    params.cutoutTop = 2.0;
    
    params.showMaskDebug = false;
    params.invertMask = true;
    params.flipMoveX = false; 
    params.flipRotY = true;
    params.flipAvatar180 = false;
    params.blackoutMode = true;
    params.smoothFactor = 0.5;
    
    Object.keys(inputs).forEach(key => {
        if(inputs[key]) inputs[key].value = params[key];
        const precision = (key.includes('offset')) ? 3 : 2;
        if(displays[key]) displays[key].innerText = params[key].toFixed(precision);
    });
    showMaskDebugCheck.checked = false;
    invertMaskCheck.checked = true;
    flipMoveXCheck.checked = false;
    flipRotYCheck.checked = true;
    flipAvatar180Check.checked = false;
    blackoutModeCheck.checked = true;

    if (avatarHolder) {
        const s = params.scale;
        avatarHolder.scale.set(s, s, s);
    }
    if(occlusionMaterial) occlusionMaterial.uniforms.uDebug.value = false;
    updateOcclusionPlaneTransform();
}

function loadImage(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = function(e) {
        standbyImg.src = e.target.result;
        standbyImg.style.display = 'block';
        privacyMessage.style.display = 'none';
        hasCustomImage = true;
        imgStatus.innerText = "ç”»åƒã‚ã‚Š";
        imgStatus.style.color = "#4ade80";
    };
    reader.readAsDataURL(file);
}

async function initMediaPipe() {
    statusText.innerText = "AIãƒ¢ãƒ‡ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ä¸­...";
    loadingEl.style.display = 'block';
    
    try {
        const vision = await FilesetResolver.forVisionTasks(
            "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.9/wasm"
        );
        
        faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
            baseOptions: {
                modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task`,
                delegate: "GPU" 
            },
            outputFaceBlendshapes: true,
            outputFacialTransformationMatrixes: true,
            runningMode: "VIDEO",
            numFaces: 1
        });

        try {
            imageSegmenter = await ImageSegmenter.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/image_segmenter/selfie_segmenter_landscape/float16/1/selfie_segmenter_landscape.tflite`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                outputCategoryMask: true,
                outputConfidenceMasks: false
            });
        } catch (segErr) {
            console.warn("Segmentation Init Error:", segErr);
            params.enableSegmentation = false;
        }
        
        statusText.innerText = "æº–å‚™å®Œäº†: VRMã‚’é¸æŠã—ã¦ãã ã•ã„";
        loadingEl.style.display = 'none';
        
    } catch (error) {
        console.error("Init Error:", error);
        statusText.innerText = "åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: " + error.message;
        document.getElementById('loadingText').innerText = "ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ";
        setTimeout(() => loadingEl.style.display = 'none', 3000);
    }
}

function loadVRM(event) {
    const file = event.target.files[0];
    if (!file) return;

    const url = URL.createObjectURL(file);
    const loader = new GLTFLoader();
    loader.register((parser) => new VRMLoaderPlugin(parser));

    statusText.innerText = "VRMèª­ã¿è¾¼ã¿ä¸­...";
    loadingEl.style.display = 'block';
    document.getElementById('loadingText').innerText = "VRMèª­ã¿è¾¼ã¿ä¸­...";

    loader.load(
        url,
        (gltf) => {
            if (currentVrm) {
                avatarHolder.remove(currentVrm.scene);
                VRMUtils.deepDispose(currentVrm.scene);
            }
            avatarHolder.position.set(0,0,0);
            avatarHolder.rotation.set(0,0,0);
            avatarHolder.scale.set(1,1,1);

            const vrm = gltf.userData.vrm;
            currentVrm = vrm;
            
            vrm.scene.traverse((obj) => {
                if (obj.isSkinnedMesh || obj.isMesh) {
                    const name = obj.name.toLowerCase();
                    const isHeadPart = name.includes('face') || name.includes('head') || name.includes('hair') || name.includes('eye') || name.includes('tooth') || name.includes('mouth') || name.includes('ear') || name.includes('brow');
                    obj.visible = isHeadPart;
                }
            });

            scene.add(vrm.scene);
            vrm.scene.updateMatrixWorld(true);
            const headBone = vrm.humanoid.getNormalizedBoneNode('head');
            let headOffset = 1.4; 
            if (headBone) {
                const headPos = new THREE.Vector3();
                headBone.getWorldPosition(headPos);
                headOffset = headPos.y; 
            }
            scene.remove(vrm.scene);
            avatarHolder.add(vrm.scene);
            vrm.scene.position.set(0, -headOffset, 0);
            
            const s = params.scale;
            avatarHolder.scale.set(s, s, s);

            VRMUtils.removeUnnecessaryVertices(vrm.scene);
            VRMUtils.removeUnnecessaryJoints(vrm.scene);

            console.log("VRM Loaded");
            statusText.innerText = "VRMèª­è¾¼å®Œäº†ã€‚ã€Œ2. é–‹å§‹ã€ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚";
            startBtn.disabled = false;
            switchCamBtn.disabled = false;
            loadingEl.style.display = 'none';
        },
        (progress) => {},
        (error) => {
            console.error(error);
            statusText.innerText = "VRMã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ";
            loadingEl.style.display = 'none';
        }
    );
}

async function switchCamera() {
    currentFacingMode = (currentFacingMode === 'user') ? 'environment' : 'user';
    if (currentStream) currentStream.getTracks().forEach(track => track.stop());
    isTracking = false;
    await startCameraAndTracking();
}

async function startCameraAndTracking() {
    if (!faceLandmarker) {
        alert("AIãƒ¢ãƒ‡ãƒ«ãŒã¾ã æº–å‚™ã§ãã¦ã„ã¾ã›ã‚“ã€‚");
        return;
    }
    
    startBtn.disabled = true;
    switchCamBtn.disabled = true;

    try {
        statusText.innerText = "ã‚«ãƒ¡ãƒ©èµ·å‹•ä¸­...";
        if (currentStream) currentStream.getTracks().forEach(track => track.stop());

        const stream = await navigator.mediaDevices.getUserMedia({ 
            video: { width: { ideal: 1280 }, height: { ideal: 720 }, facingMode: currentFacingMode } 
        });
        currentStream = stream;
        videoElement.srcObject = stream;
        
        if (currentFacingMode === 'user') {
            videoElement.style.transform = 'scaleX(-1)';
        } else {
            videoElement.style.transform = 'scaleX(1)';
        }

        await videoElement.play();
        
        await new Promise((resolve) => {
            if (videoElement.readyState >= 2) {
                resolve();
            } else {
                videoElement.onloadeddata = () => resolve();
                setTimeout(resolve, 3000);
            }
        });
        onWindowResize();

        videoTexture = new THREE.VideoTexture(videoElement);
        videoTexture.colorSpace = THREE.SRGBColorSpace;
        scene.background = null; 

        // Layer 3: Body Occlusion
        if (params.enableSegmentation && imageSegmenter) {
            if (!occlusionPlane) {
                maskCanvas = document.createElement('canvas');
                maskCanvas.width = videoElement.videoWidth;
                maskCanvas.height = videoElement.videoHeight;
                maskCtx = maskCanvas.getContext('2d');

                segmentationMaskTexture = new THREE.CanvasTexture(maskCanvas);
                segmentationMaskTexture.minFilter = THREE.LinearFilter;
                
                occlusionMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        uVideo: { value: videoTexture },
                        uMask: { value: segmentationMaskTexture },
                        uDebug: { value: params.showMaskDebug }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform sampler2D uVideo;
                        uniform sampler2D uMask;
                        uniform bool uDebug;
                        varying vec2 vUv;
                        void main() {
                            vec4 videoColor = texture2D(uVideo, vUv);
                            float maskAlpha = texture2D(uMask, vUv).a;
                            if (uDebug) {
                                gl_FragColor = vec4(1.0, 0.0, 0.0, maskAlpha * 0.6);
                            } else {
                                if (maskAlpha > 0.5) {
                                    gl_FragColor = vec4(videoColor.rgb, 1.0);
                                } else {
                                    discard;
                                }
                            }
                        }
                    `,
                    transparent: true,
                    side: THREE.DoubleSide,
                    depthWrite: true 
                });
                
                occlusionPlane = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), occlusionMaterial);
                occlusionPlane.renderOrder = 999; 
                occlusionPlane.position.set(0, 0, 0.5); 
                occlusionPlane.visible = false; 
                
                scene.add(occlusionPlane);
            }
            updateOcclusionPlaneTransform();
        }

        isTracking = true;
        startBtn.innerText = "å‹•ä½œä¸­";
        statusText.innerText = "ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°ä¸­";
        
        animate();
        
    } catch (e) {
        console.error("Camera Error:", e);
        statusText.innerText = "ã‚«ãƒ¡ãƒ©èµ·å‹•å¤±æ•—: " + e.message;
        startBtn.disabled = false;
        switchCamBtn.disabled = false;
    }
}

function updateOcclusionPlaneTransform() {
    if (!occlusionPlane || !videoElement || videoElement.videoWidth === 0) return;

    occlusionPlane.visible = params.enableSegmentation;
    if (!params.enableSegmentation) return;

    const videoAspect = videoElement.videoWidth / videoElement.videoHeight;
    const screenAspect = window.innerWidth / window.innerHeight;
    
    const distance = 0.5; 
    const vFOV = camera.fov * Math.PI / 180;
    
    const visibleHeight = 2 * Math.tan(vFOV / 2) * distance;
    const visibleWidth = visibleHeight * screenAspect;

    let scaleX, scaleY;

    if (screenAspect > videoAspect) {
        scaleX = visibleWidth;
        scaleY = visibleWidth / videoAspect; 
    } else {
        scaleY = visibleHeight;
        scaleX = visibleHeight * videoAspect; 
    }
    
    const isFront = (currentFacingMode === 'user');
    const dir = isFront ? -1 : 1;
    
    occlusionPlane.scale.set(scaleX * dir, scaleY, 1);
}

function animate() {
    requestAnimationFrame(animate);
    const deltaTime = clock.getDelta();
    let startTimeMs = performance.now();

    if (isTracking && videoElement.readyState >= 2 && videoElement.videoWidth > 0) { 
        if (videoElement.currentTime !== lastVideoTime) {
            lastVideoTime = videoElement.currentTime;
            
            try {
                const faceResult = faceLandmarker.detectForVideo(videoElement, startTimeMs);
                let faceLandmarks = null;
                
                if (faceResult.faceLandmarks && faceResult.faceLandmarks.length > 0) {
                    faceLandmarks = faceResult.faceLandmarks[0]; 
                    updateAvatarTargetPose(faceResult);
                    
                    if (currentVrm) currentVrm.scene.visible = true;
                    if (occlusionPlane) occlusionPlane.visible = true; 

                    videoElement.style.opacity = 1;
                    standbyLayer.style.opacity = 0;

                    statusText.innerText = "ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°ä¸­";
                } 
                else {
                    statusText.innerText = "é¡”ã‚’æ¢ã—ã¦ã„ã¾ã™...";
                    if (params.blackoutMode) {
                        if (currentVrm) currentVrm.scene.visible = false;
                        if (occlusionPlane) occlusionPlane.visible = false;
                        videoElement.style.opacity = 0;
                        standbyLayer.style.opacity = 1;
                    }
                }

                if (imageSegmenter && occlusionPlane && occlusionMaterial && params.enableSegmentation) {
                    const segResult = imageSegmenter.segmentForVideo(videoElement, startTimeMs);
                    if (segResult) {
                        try {
                            if (segResult.categoryMask) {
                                updateOcclusionMask(segResult.categoryMask, faceLandmarks);
                                maskUpdateCount++;
                            }
                        } finally {
                            if (segResult.categoryMask) segResult.categoryMask.close();
                            if (segResult.confidenceMasks) {
                                for (const m of segResult.confidenceMasks) m.close();
                            }
                        }
                    }
                    occlusionMaterial.needsUpdate = true;
                    if(segmentationMaskTexture) segmentationMaskTexture.needsUpdate = true;
                    
                    occlusionMaterial.uniforms.uDebug.value = params.showMaskDebug;
                }
            } catch (e) {
               console.warn(e);
            }
        }
    }
    
    if (currentVrm && avatarHolder) {
        const t = Math.min(Math.max(params.smoothFactor, 0.01), 1.0);
        avatarHolder.position.lerp(targetPosition, t);
        avatarHolder.quaternion.slerp(targetQuaternion, t);
        
        if (currentVrm.expressionManager) {
            Object.keys(targetExpressions).forEach(name => {
                const targetVal = targetExpressions[name];
                const currentVal = currentVrm.expressionManager.getValue(name);
                const nextVal = currentVal + (targetVal - currentVal) * t;
                currentVrm.expressionManager.setValue(name, nextVal);
            });
        }
        currentVrm.update(deltaTime);
    }
    
    renderer.render(scene, camera);
}

// ä¿®æ­£: é¡”ã®è¼ªéƒ­ã«æ²¿ã£ã¦ç©´ã‚’ã‚ã‘ã‚‹
function updateOcclusionMask(mask, faceLandmarks) {
    if (maskCanvas.width !== videoElement.videoWidth) {
        maskCanvas.width = videoElement.videoWidth;
        maskCanvas.height = videoElement.videoHeight;
    }

    const width = maskCanvas.width;
    const height = maskCanvas.height;
    const maskArray = mask.getAsUint8Array(); 
    const imgData = maskCtx.createImageData(width, height);
    const invert = params.invertMask;
    
    // ä½“å…¨ä½“ã®ãƒã‚¹ã‚¯ã‚’æç”» (ã“ã“ã¾ã§ã¯åŒã˜)
    for (let i = 0; i < width * height; ++i) {
        const category = maskArray[i];
        const pixelIndex = i * 4;
        let alpha;

        const isPerson = category > 0;
        let shouldMask = isPerson;
        if (invert) shouldMask = !shouldMask; 

        alpha = shouldMask ? 255 : 0;
        
        imgData.data[pixelIndex] = 255;     
        imgData.data[pixelIndex + 1] = 255;   
        imgData.data[pixelIndex + 2] = 255;   
        imgData.data[pixelIndex + 3] = alpha; 
    }

    maskCtx.putImageData(imgData, 0, 0);
    
    // é¡”ã®éƒ¨åˆ†ã ã‘ç©´ã‚’ã‚ã‘ã‚‹ (ã“ã“ã‚’ä¿®æ­£)
    if (faceLandmarks) {
        maskCtx.globalCompositeOperation = 'destination-out'; 
        maskCtx.fillStyle = 'rgba(0,0,0,1)'; 
        
        // 1. é‡å¿ƒã‚’è¨ˆç®—
        let cx = 0, cy = 0;
        const pts = [];
        for(let i=0; i<FACE_OVAL_INDICES.length; i++) {
            const p = faceLandmarks[FACE_OVAL_INDICES[i]];
            // åº§æ¨™ã‚’Canvasã‚µã‚¤ã‚ºã«å¤‰æ›
            const x = p.x * width;
            const y = p.y * height;
            pts.push({x, y});
            cx += x;
            cy += y;
        }
        cx /= pts.length;
        cy /= pts.length;
        
        // 2. ãƒ‘ã‚¹ã‚’ä½œæˆ (ä¸­å¿ƒã‹ã‚‰æ‹¡å¤§ã—ã¦æç”»)
        maskCtx.beginPath();
        
        for(let i=0; i<pts.length; i++) {
            let px = pts[i].x;
            let py = pts[i].y;
            
            // é‡å¿ƒã‹ã‚‰ã®ãƒ™ã‚¯ãƒˆãƒ«
            let vx = px - cx;
            let vy = py - cy;
            
            // æ‹¡å¼µä¿‚æ•°ã®æ±ºå®š
            // é€šå¸¸ã®ã‚¹ã‚±ãƒ¼ãƒ«
            let scale = params.cutoutScale;
            
            // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒ0ä»˜è¿‘(ãŠã§ã“)ã‹18ä»˜è¿‘(ã‚¢ã‚´)ã‹ã§ã‚¹ã‚±ãƒ¼ãƒ«ã‚’å¤‰ãˆã‚‹
            // FACE_OVAL_INDICES[0]ã¯é¡(10), FACE_OVAL_INDICES[18]ã¯ã‚¢ã‚´(152)
            
            // ç°¡æ˜“çš„ã«Yåº§æ¨™ã§åˆ¤å®šï¼šé‡å¿ƒã‚ˆã‚Šä¸Šãªã‚‰TopScaleã€ä¸‹ãªã‚‰BottomScaleã‚’ãƒ–ãƒ¬ãƒ³ãƒ‰
            if (vy < 0) {
                // ä¸Šï¼ˆãŠã§ã“å´ï¼‰
                scale *= params.cutoutTop; // é«ªã®æ¯›å¯¾ç­–ã§å¤§ããåºƒã’ã‚‹
            } else {
                // ä¸‹ï¼ˆã‚¢ã‚´å´ï¼‰
                scale *= params.cutoutBottom;
            }

            const nx = cx + vx * scale;
            const ny = cy + vy * scale;
            
            if(i===0) maskCtx.moveTo(nx, ny);
            else maskCtx.lineTo(nx, ny);
        }
        
        maskCtx.closePath();
        maskCtx.fill();

        maskCtx.globalCompositeOperation = 'source-over';
    }

    if (segmentationMaskTexture) {
        segmentationMaskTexture.needsUpdate = true;
    }
    
    if (maskUpdateCount % 60 === 0) {
        debugInfo.innerText = `Mask OK`;
    }
}

function updateAvatarTargetPose(result) {
    if (!currentVrm || !avatarHolder) return;
    
    const matrix = result.facialTransformationMatrixes[0].data;
    const blendshapes = result.faceBlendshapes[0].categories;
    const mpMatrix = new THREE.Matrix4().fromArray(matrix);
    const position = new THREE.Vector3();
    const quaternion = new THREE.Quaternion();
    const scale = new THREE.Vector3();
    mpMatrix.decompose(position, quaternion, scale);
    const AR_SCALE_FACTOR = 0.08; 
    
    const xDir = params.flipMoveX ? 1 : -1;
    const yRotDir = params.flipRotY ? -1 : 1;
    const avatarRot = params.flipAvatar180 ? Math.PI : 0;

    targetPosition.x = (position.x * AR_SCALE_FACTOR * xDir) + params.offsetX; 
    targetPosition.y = (position.y * AR_SCALE_FACTOR) + params.offsetY;
    targetPosition.z = (position.z * AR_SCALE_FACTOR) + params.offsetZ;
    
    const euler = new THREE.Euler().setFromQuaternion(quaternion, 'YXZ');
    const finalEuler = new THREE.Euler(
        euler.x, 
        (euler.y * yRotDir) + Math.PI + avatarRot, 
        euler.z, 
        'YXZ'
    );
    targetQuaternion.setFromEuler(finalEuler);
    
    const map = { 'jawOpen': 'aa', 'mouthPucker': 'ou', 'mouthSmileLeft': 'happy', 'mouthSmileRight': 'happy', 'eyeBlinkLeft': 'blinkLeft', 'eyeBlinkRight': 'blinkRight', 'browInnerUp': 'surprised' };
    
    blendshapes.forEach(shape => { 
        const vrmName = map[shape.categoryName]; 
        if (vrmName) {
            targetExpressions[vrmName] = shape.score;
        }
    });
    
    const smileL = blendshapes.find(b => b.categoryName === 'mouthSmileLeft')?.score || 0;
    const smileR = blendshapes.find(b => b.categoryName === 'mouthSmileRight')?.score || 0;
    targetExpressions['happy'] = Math.max(smileL, smileR);
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    updateOcclusionPlaneTransform();
}

init();
</script>
</body>
</html>
